State of Charge
Overview


Coulomb counting
This count accumulates the coulomb 
A
.
s
 that are passing through the battery.

It relies on the current measurement to provide an accurate accumulation.

The is obtained from 3 sources, each source has an error associated with it.

The current sensor
The peripheral system consumption
The sleep/internal consumption of battery and BMS
Based on the current and error in the current, the coulomb count is given by: 
[
C
c
m
i
n
(
t
)
,
C
c
m
a
x
(
t
)
]
=
∫
t
t
0
I
(
t
)
±
I
s
e
n
s
e
E
r
r
(
t
)
⋅
d
t
Coulomb count to SOC
S
O
C
(
t
+
d
t
)
=
S
O
C
(
t
)
+
d
S
O
C
d
S
O
C
=
d
C
c
C
(
t
+
d
t
)
C
(
t
)
 is the charge acceptance dependant on temperature, discharge rate & SOH.
dCc is the coulomb counting variation during the 
d
t
 period.
d
C
c
=
C
c
(
t
+
d
t
)
−
C
c
(
t
)
d
C
c
=
∫
t
+
d
t
t
I
(
t
)
±
I
s
e
n
s
e
E
r
r
(
I
,
T
)
⋅
d
t
d
C
c
=
k
+
n
∑
i
=
k
 
[
I
(
k
)
±
I
s
e
n
s
e
E
r
r
(
I
,
T
)
]
⋅
d
T
To avoid rounding error and computation overload, 
S
O
C
+
d
S
O
C
 is only performed when 
d
C
c
>
d
C
c
t
h
 of the effective battery capacity

This threshold causes the 
d
t
 to vary depending on the charge/discharge with a characteristic value of 10 seconds when the battery is used at a C-rate of 1.

d
C
c
t
h
=
D
1
C
∗
10
Approximating C(t)
During the SOC calculation, 
d
S
O
C
 is calculated based on the current charge acceptance of the battery pack.

C
=
S
O
H
∗
D
1
C
∗
K
(
T
,
R
a
t
e
)
K
 is a 2D matrix providing the charge acceptance function of temperature and rate of charge/discharge
This table is provided as a configuration parameter.

Voltage based recalibration
Voltage-based recalibration compensates coulomb counting drift caused by the accumulation of 
I
s
e
n
s
e
E
r
r
(
I
,
T
)
 over-time.

S
O
C
v
H
 & 
S
O
C
v
L
 are then derived from the 
S
O
C
(
O
C
V
H
f
|
L
f
,
T
)
 table and linear interpolation.



The algorithm will make sure that other estimators do not drift further than the H&L boundaries.



OCV estimation & conditionning

O
C
V
=
V
t
e
r
m
−
V
d
y
n
V
d
y
n
=
V
D
C
+
V
R
C
1
+
V
R
C
2
Terminal module voltage & 
V
d
y
n
 are both subject to errors. H & L values are developped to take these errors into account and provide an OCV estimation range.

O
C
V
H
=
V
t
e
r
m
H
−
V
d
y
n
L
O
C
V
L
=
V
t
e
r
m
L
−
V
d
y
n
H
V
t
e
r
m
H
|
L
=
V
t
e
r
m
±
E
r
r
V
m
e
a
s
OCV is maximized (H) when Vdyn is minimized (L). To mitigate the error induced by asynchronous current & voltage sampling, a median filter 
F
m
e
d
i
a
n
 of X samples (16 in most platform) is used.

O
C
V
H
m
|
L
m
=
F
(
O
C
V
H
|
L
)
To remove high-frequency noise, this output is filtered further using a low-pass filter 
H
 of time constant 
τ
f
O
C
V
H
f
|
L
f
=
H
(
O
C
V
H
m
|
L
m
)
O
C
V
H
f
|
L
f
=
O
C
V
H
m
|
L
m
∗
τ
f
+
(
1
−
τ
f
)
∗
O
C
V
H
f
|
L
f
−
1
Vdyn Calculation

V
d
y
n
H
=
V
D
C
H
+
V
R
C
1
H
+
V
R
C
2
H
V
d
y
n
L
=
V
D
C
L
+
V
R
C
1
L
+
V
R
C
2
L
V
d
y
n
 is maximized when all its components are maximized.

V
X
Y
+
=
V
X
Y
−
1
∗
τ
X
Y
+
R
X
Y
∗
(
1
−
τ
X
Y
)
∗
I
X
=
[
D
C
,
R
C
1
,
R
C
2
]
Y
=
[
H
,
L
]
(
τ
D
C
Y
=
0
)

V
d
y
n
 components are maximized when 
R
x
 are maximized for positive current, and minimized for negative current.

R
X
H
=
{
R
X
m
a
x
,
if 
I
>
0
,
R
X
m
i
n
,
otherwise
R
X
L
=
{
R
X
m
i
n
,
if 
I
>
0
,
R
X
m
a
x
,
otherwise
Further more, dynamic components of 
V
d
y
n
 are maximized by minimizing their time constant 
τ
 during growth (
V
d
y
n
H
<
V
f
i
n
a
l
H
) and maximized during decay (
V
d
y
n
H
>
V
f
i
n
a
l
H
)

Where 
V
f
i
n
a
l
Y
=
∑
n
−
1
x
=
0
R
X
Y
∗
I
 with 
n
 the number of branches (3 in this case)

τ
X
H
=
{
τ
m
i
n
,
if 
V
d
y
n
H
<
V
f
i
n
a
l
H
,
τ
m
a
x
,
otherwise
τ
X
L
=
{
τ
m
a
x
,
if 
V
d
y
n
L
<
V
f
i
n
a
l
L
,
τ
m
a
x
,
otherwise
The min/max parameters are derived from their confidence level (static/dynamic error)

R
X
m
a
x
=
R
X
∗
(
1
+
E
r
r
s
t
a
t
i
c
)
R
X
m
i
n
=
R
X
∗
1
1
+
E
r
r
s
t
a
t
i
c
C
X
m
a
x
=
C
X
∗
(
1
+
E
r
r
d
y
n
a
m
i
c
)
C
X
m
i
n
=
C
X
∗
1
1
+
E
r
r
s
t
a
t
i
c
τ
m
a
x
=
e
−
Δ
T
/
(
R
m
a
x
C
m
a
x
)
τ
m
i
n
=
e
−
Δ
T
/
(
R
X
m
i
n
C
X
m
i
n
)
Module Serialization
The voltage involved in this algorithm is taken at the module level. In a battery stack, multiple modules are in series, this multiple 
S
O
C
 will be calculated.

The algorithm continuously estimates the open circuit voltage of the cells that have the highest and lowest terminal voltage.

The OCV H and L are calculated for max and min terminal voltage cell in the battery. For Each OCV a corresponding SOC is extracted from SOC-OCV table. Hence there are 4 values that define boundaries for final SOC estimation.

The index nomenclature is given by the following table

Position	Symbol	Description
1	
v
Module voltage SOC estimation
1	
i
Current based SOC estimation (coulomb compting)
2	
H
Error maximized
2	
L
Error minimized
2	
A
Average error
3	
m
Least charge module
3	
M
Most charged module
S
O
C
v
L
m
S
O
C
v
H
m
S
O
C
v
L
M
S
O
C
v
H
M
The coulomb count also uses H & L values for error in current measurement. And has 4 values for min and max cell voltages

S
O
C
i
L
m
S
O
C
i
H
m
S
O
C
i
L
M
S
O
C
i
H
M
Initially, 
S
O
C
i
H
m
 & 
S
O
C
i
H
M
 are equal to each other and 
S
O
C
i
L
m
 & 
S
O
C
i
L
M
 are equal to each other as, the coulomb count does not take voltage into consideration. They deviate from each other when corrected by corresponding 
S
O
C
v
 values.

We consider the battery 
S
O
C
r
e
a
l
 as the weighted average of the 
S
O
C
 of the least charged module 
S
O
C
m
i
n
 and the 
S
O
C
 of the most charged module 
S
O
C
m
a
x
S
O
C
i
A
m
=
(
S
O
C
i
L
m
+
S
O
C
i
H
m
)
/
2
S
O
C
i
A
M
=
(
S
O
C
i
L
M
+
S
O
C
i
H
M
)
/
2
Δ
S
O
C
i
A
=
S
O
C
i
A
M
−
S
O
C
i
A
m
S
O
C
r
e
a
l
=
(
100
∗
S
O
C
i
A
m
)
/
(
100
−
Δ
S
O
C
i
A
)
User SOC
The 
S
O
C
r
e
a
l
 is not the SOC that is shown to the user for following reasons

For depth of discharge(DoD) less than 100%
Spikes in 
S
O
C
r
e
a
l
 because of constant recalibration by 
S
O
C
v
 values.
To mitigate this concept of 
S
O
C
u
s
e
r
 has been introduced

E.g If the DoD is kept at 70% i.e battery is only operated from 15-85% SOC. But user would like to see the SOC range translated into 0-100% This can be achieved using configuration params 
S
O
C
f
a
c
t
o
r
 and 
S
O
C
o
f
f
s
e
t
D
o
D
m
a
x
=
85
D
o
D
m
i
n
=
15
S
O
C
o
f
f
s
e
t
=
−
(
D
o
D
m
i
n
∗
100
)
/
(
D
o
D
m
a
x
−
D
o
D
m
i
n
)
S
O
C
f
a
c
t
o
r
=
(
100
/
(
D
o
D
m
a
x
−
D
o
D
m
i
n
)
S
O
C
u
s
e
r
 is a low pass filtered version of 
S
O
C
r
e
a
l
 to remove gliches in the 
S
O
C
r
e
a
l
.

A filter with a low time constant is used when 
I
s
e
n
s
e
 is more than 
I
d
e
a
d
z
o
n
e
 range

A filter with a high time constant is used when 
I
s
e
n
s
e
 is less than 
I
d
e
a
d
z
o
n
e
 range to avoid any rapid 
S
O
C
u
s
e
r
 change for zero current.

SOC Features
To SOC for a given OCV is extracted form a SOC-OCV table. The SOC-OCV table is a function of 2 parmaters

Temperature
Current (Charge / Discharge)
To eliminate gliches in SOC while switching between SOC tables linear interpolation is incorporated.